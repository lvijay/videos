keySpeak     = Σ
keyTab       = τ
keyNewline   = η
keyBackspace = ‹
keyAlt       = æ
Terminal window size = 81x21
Same hashcode: AxE, BYE; axe, bYe

rectangle = x,y,w,h = 22,154,1400,788
screencapture -k -v -g -R 22,154,1400,788 -V45 hashmap004.mov
----
¶alias emacs='~/Applications/Emacs.app/Contents/MacOS/emacs-nw --no-init-file --no-splash --eval "(load (expand-file-name \"~/other-code/videos/hashmap/el-hashmap.el\"))"'
rm -f hashmap-draw.txt hashmap-draw.txt~
clear
emacs hashmap-draw.txt
¶⑤¶Avoidance¶
¶---------¶«¢u«1«¢l«⑤
1. Do not use mutable objects in classes that invoke hashCode
   - this includes maps like LinkedHashMap, TreeMap, ConcurrentHashMap and
- sets like HashSet, TreeSet
«æ\«2. If a mutable object is hashed in your data structure, ensure the reference
   does not escape.  You can do this by ensuring:
a. The object you put in the map is not reachable outside
b. Only return copies of the hashed object.
   i. This includes making a copy in your regular return methods and
ii. complex methods like keySet(), entrySet(), iterator()
«æ\«④

¶Mitigation¶
¶----------¶«¢u«1«¢l«©

You find yourself maintaining a codebase where mutable objects are
hashed.  What do you do?  (In my experience the Lombok framework makes
making these mistakes easy.)

For all mitigation, there are levels of exposure to the problem.
You're allowed to make fewer changes when the exposure is greater.

Let's start with the least invasive fix.

Change your hashCode implementation.  Use the following:

public int hashCode() { return 1; }

This change guarantees your map will always look in the correct array
index when looking for an element.  It will kill performance because
your maps will behave like lists but your behavior will be correct.

The most invasive fix is to remove all your setters and make your
hashed objects immutable.

«¢xs««¢xc«
# With that we are done with this HashMap exploration.
